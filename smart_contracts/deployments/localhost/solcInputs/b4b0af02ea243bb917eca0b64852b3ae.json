{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/Swap.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.9;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\r\n\r\ncontract Swap is Ownable {\r\n    //custom data structures for implementing features\r\n\r\n    //To store token details\r\n    struct Token {\r\n        address contractAddress;\r\n        string symbolName;\r\n    }\r\n\r\n    //to store individual order details\r\n    struct Order {\r\n        uint256 quantity;\r\n        uint256 price;\r\n        uint256 timestamp;\r\n        address user;\r\n        bytes2 status;\r\n    }\r\n\r\n    //to store the whole list of specific types of orders for each market\r\n    struct OrderBook {\r\n        uint256 orderIndex;\r\n        mapping(uint256 => Order) orders;\r\n        uint256 ordersCount;\r\n        uint256[] ordersQueue;\r\n    }\r\n\r\n    //Each market is made of corresponding buy orderbook and sell orderbook\r\n    struct Market {\r\n        OrderBook buyOrderBook;\r\n        OrderBook sellOrderBook;\r\n    }\r\n\r\n    //Mapping for storage\r\n\r\n    mapping(uint8 => Token) tokenInfo;\r\n    mapping(uint8 => IERC20) tokens;\r\n    mapping(address => mapping(uint8 => uint256)) tokenBalanceForAddress;\r\n    mapping(uint8 => uint8[]) buyToSell; //mapping of market index to the corresponding buy and sell token for that market\r\n    mapping(uint8 => Market) ExchangeMarket;\r\n    uint8 tokenIndex; //total types of tokens available\r\n    uint8 marketIndex; //total types of markets\r\n\r\n    constructor() {\r\n        tokenIndex = 0;\r\n        marketIndex = 0;\r\n    }\r\n\r\n    /* EVENTS */\r\n\r\n    event LogDepositToken(\r\n        string symbolName,\r\n        address accountAddress,\r\n        uint256 amount,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event LogWithdrawToken(\r\n        string symbolName,\r\n        address accountAddress,\r\n        uint256 amount,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event LogAddToken(\r\n        uint256 tokenIndex,\r\n        string symbolName,\r\n        address EC20TokenAddress,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event LogAddMarket(uint256 marketIndex, string symbolName, uint256 timestamp);\r\n\r\n    event LogBuyToken(\r\n        string symbolName1,\r\n        string symbolName2,\r\n        uint256 price,\r\n        uint256 amount,\r\n        address buyer,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event LogSellToken(\r\n        string symbolName1,\r\n        string symbolName2,\r\n        uint256 price,\r\n        uint256 amount,\r\n        address buyer,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event LogCreateBuyOrder(\r\n        string symbolName1,\r\n        string symbolName2,\r\n        uint256 price,\r\n        uint256 amount,\r\n        address buyer,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event LogCreateSellOrder(\r\n        string symbolName1,\r\n        string symbolName2,\r\n        uint256 price,\r\n        uint256 amount,\r\n        address seller,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event LogFulfilBuyOrder(\r\n        string symbolName1,\r\n        string symbolName2,\r\n        uint256 price,\r\n        uint256 orderIndex,\r\n        uint256 amount,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event LogFulfilSellOrder(\r\n        string symbolName1,\r\n        string symbolName2,\r\n        uint256 price,\r\n        uint256 orderIndex,\r\n        uint256 amount,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event LogCancelBuyOrder(\r\n        string symbolName1,\r\n        string symbolName2,\r\n        uint256 orderIndex,\r\n        address buyer,\r\n        uint256 timestamp\r\n    );\r\n    event LogCancelSellOrder(\r\n        string symbolName1,\r\n        string symbolName2,\r\n        uint256 orderIndex,\r\n        address seller,\r\n        uint256 timestamp\r\n    );\r\n\r\n    /* FUNCTIONS TO PROVIDE FEATURES */\r\n\r\n    // Owner's AddToken ability\r\n    function addToken(string memory symbolName, address EC20TokenAddress) public onlyOwner {\r\n        require(!hasToken(symbolName), \"Token already exists\");\r\n        require(tokenIndex + 1 >= tokenIndex, \"Token Index overflow\");\r\n\r\n        tokenIndex++;\r\n        tokenInfo[tokenIndex].symbolName = symbolName;\r\n        tokenInfo[tokenIndex].contractAddress = EC20TokenAddress;\r\n        tokens[tokenIndex] = IERC20(tokenInfo[tokenIndex].contractAddress);\r\n\r\n        emit LogAddToken(tokenIndex, symbolName, EC20TokenAddress, block.timestamp);\r\n\r\n        addMarket(symbolName, tokenIndex);\r\n    }\r\n\r\n    //A Market is added with combination with previous tokens so all exchanges are available\r\n    function addMarket(string memory symbolName, uint8 _tokenIndex) public onlyOwner {\r\n        require(marketIndex + 1 >= marketIndex);\r\n\r\n        for (uint8 i = 1; i < tokenIndex; i++) {\r\n            marketIndex++;\r\n            uint8[] memory toAdd = new uint8[](2);\r\n            toAdd[0] = _tokenIndex;\r\n            toAdd[1] = i;\r\n            buyToSell[marketIndex] = toAdd;\r\n        }\r\n\r\n        emit LogAddMarket(marketIndex, symbolName, block.timestamp);\r\n    }\r\n\r\n    // Address's Tokens account management - ability to deposit tokens\r\n    function depositToken(string memory symbolName, uint256 amount)\r\n        public\r\n        returns (uint256 tokenBalance)\r\n    {\r\n        require(hasToken(symbolName));\r\n        require(getTokenBalanceForUser(symbolName) + amount >= getTokenBalanceForUser(symbolName));\r\n        uint8 _tokenIndex = getTokenIndex(symbolName);\r\n        tokenBalanceForAddress[msg.sender][_tokenIndex] += amount;\r\n        require(tokens[_tokenIndex].transferFrom(msg.sender, address(this), amount) == true);\r\n        emit LogDepositToken(symbolName, msg.sender, amount, block.timestamp);\r\n        return getTokenBalanceForUser(symbolName);\r\n    }\r\n\r\n    // Address's Tokens account management - ability to withdraw tokens\r\n    function withdrawToken(string memory symbolName, uint256 amount)\r\n        public\r\n        returns (uint256 tokenBalance)\r\n    {\r\n        require(hasToken(symbolName));\r\n        require(amount <= getTokenBalanceForUser(symbolName));\r\n\r\n        uint8 _tokenIndex = getTokenIndex(symbolName);\r\n        tokenBalanceForAddress[msg.sender][_tokenIndex] -= amount;\r\n        require(tokens[_tokenIndex].transfer(msg.sender, amount) == true);\r\n\r\n        emit LogWithdrawToken(symbolName, msg.sender, amount, block.timestamp);\r\n        return getTokenBalanceForUser(symbolName);\r\n    }\r\n\r\n    //User submits market buy order\r\n    function buyMarketOrder(\r\n        string memory buyTokenSymbol,\r\n        string memory sellTokenSymbol,\r\n        uint256 quantity\r\n    ) private {\r\n        require(hasToken(buyTokenSymbol));\r\n        require(hasToken(sellTokenSymbol));\r\n\r\n        uint8 _sellTokenIndex = getTokenIndex(sellTokenSymbol);\r\n        uint8 _buyTokenIndex = getTokenIndex(buyTokenSymbol);\r\n        uint8 _marketIndex = getMarketIndex(buyTokenSymbol, sellTokenSymbol);\r\n        require(ExchangeMarket[_marketIndex].sellOrderBook.ordersCount > 0, \"Cannot place request\");\r\n        uint256 _buy_qty_balance = quantity;\r\n        uint256 _currSellOrdersCount = ExchangeMarket[_marketIndex].sellOrderBook.ordersCount;\r\n\r\n        uint256 _countSellOrderFulfiled = 0;\r\n        for (uint256 i = 0; i < _currSellOrdersCount; i++) {\r\n            if (_buy_qty_balance == 0) break;\r\n\r\n            uint256 _orderIndex = ExchangeMarket[_marketIndex].sellOrderBook.ordersQueue[i];\r\n            uint256 _orderPrice = ExchangeMarket[_marketIndex]\r\n                .sellOrderBook\r\n                .orders[_orderIndex]\r\n                .price;\r\n            uint256 _orderAmount = ExchangeMarket[_marketIndex]\r\n                .sellOrderBook\r\n                .orders[_orderIndex]\r\n                .quantity;\r\n            address _orderOwner = ExchangeMarket[_marketIndex]\r\n                .sellOrderBook\r\n                .orders[_orderIndex]\r\n                .user;\r\n            if (_buy_qty_balance >= _orderAmount) {\r\n                _buy_qty_balance -= _orderAmount;\r\n\r\n                ExchangeMarket[_marketIndex].sellOrderBook.orders[_orderIndex].quantity = 0;\r\n                _countSellOrderFulfiled++;\r\n                emit LogFulfilSellOrder(\r\n                    sellTokenSymbol,\r\n                    buyTokenSymbol,\r\n                    _orderIndex,\r\n                    _orderPrice,\r\n                    _orderAmount,\r\n                    block.timestamp\r\n                );\r\n                tokenBalanceForAddress[msg.sender][_sellTokenIndex] -= _orderPrice * _orderAmount;\r\n                tokenBalanceForAddress[_orderOwner][_sellTokenIndex] += _orderPrice * _orderAmount;\r\n                tokenBalanceForAddress[msg.sender][_buyTokenIndex] += _orderAmount;\r\n            } else {\r\n                ExchangeMarket[_marketIndex]\r\n                    .sellOrderBook\r\n                    .orders[_orderIndex]\r\n                    .quantity -= _buy_qty_balance;\r\n                emit LogFulfilSellOrder(\r\n                    sellTokenSymbol,\r\n                    buyTokenSymbol,\r\n                    _orderIndex,\r\n                    _orderPrice,\r\n                    _orderAmount,\r\n                    block.timestamp\r\n                );\r\n\r\n                tokenBalanceForAddress[msg.sender][_sellTokenIndex] -=\r\n                    _orderPrice *\r\n                    _buy_qty_balance;\r\n                tokenBalanceForAddress[_orderOwner][_sellTokenIndex] +=\r\n                    _orderPrice *\r\n                    _buy_qty_balance;\r\n                tokenBalanceForAddress[msg.sender][_buyTokenIndex] += _buy_qty_balance;\r\n\r\n                _buy_qty_balance = 0;\r\n            }\r\n        }\r\n\r\n        // update sellOrderBook - ordersBook and ordersCount\r\n        uint256 _newSellOrdersCount = _currSellOrdersCount - _countSellOrderFulfiled;\r\n\r\n        uint256[] memory _newSellOrdersQueue = new uint256[](_newSellOrdersCount);\r\n        for (uint256 i = 0; i < _newSellOrdersCount; i++) {\r\n            _newSellOrdersQueue[i] = ExchangeMarket[_marketIndex].sellOrderBook.ordersQueue[\r\n                i + _countSellOrderFulfiled\r\n            ];\r\n        }\r\n\r\n        ExchangeMarket[_marketIndex].sellOrderBook.ordersCount = _newSellOrdersCount;\r\n        ExchangeMarket[_marketIndex].sellOrderBook.ordersQueue = _newSellOrdersQueue;\r\n    }\r\n\r\n    function sellMarketOrder(\r\n        string memory buyTokenSymbol,\r\n        string memory sellTokenSymbol,\r\n        uint256 quantity\r\n    ) private {\r\n        require(hasToken(buyTokenSymbol));\r\n        require(hasToken(sellTokenSymbol));\r\n\r\n        uint8 _sellTokenIndex = getTokenIndex(sellTokenSymbol);\r\n        uint8 _buyTokenIndex = getTokenIndex(buyTokenSymbol);\r\n        uint8 _marketIndex = getMarketIndex(sellTokenSymbol, buyTokenSymbol);\r\n        require(ExchangeMarket[_marketIndex].buyOrderBook.ordersCount > 0, \"Cannot place request\");\r\n        uint256 _sell_qty_balance = quantity;\r\n        uint256 _currBuyOrdersCount = ExchangeMarket[_marketIndex].buyOrderBook.ordersCount;\r\n\r\n        uint256 _countBuyOrderFulfiled = 0;\r\n        for (uint256 i = 0; i < _currBuyOrdersCount; i++) {\r\n            if (_sell_qty_balance == 0) break;\r\n\r\n            uint256 _orderIndex = ExchangeMarket[_marketIndex].buyOrderBook.ordersQueue[i];\r\n            uint256 _orderPrice = ExchangeMarket[_marketIndex]\r\n                .buyOrderBook\r\n                .orders[_orderIndex]\r\n                .price;\r\n            uint256 _orderAmount = ExchangeMarket[_marketIndex]\r\n                .buyOrderBook\r\n                .orders[_orderIndex]\r\n                .quantity;\r\n            address _orderOwner = ExchangeMarket[_marketIndex]\r\n                .buyOrderBook\r\n                .orders[_orderIndex]\r\n                .user;\r\n            if (_sell_qty_balance >= _orderAmount) {\r\n                _sell_qty_balance -= _orderAmount;\r\n\r\n                ExchangeMarket[_marketIndex].buyOrderBook.orders[_orderIndex].quantity = 0;\r\n                _countBuyOrderFulfiled++;\r\n                emit LogFulfilBuyOrder(\r\n                    sellTokenSymbol,\r\n                    buyTokenSymbol,\r\n                    _orderIndex,\r\n                    _orderPrice,\r\n                    _orderAmount,\r\n                    block.timestamp\r\n                );\r\n                tokenBalanceForAddress[msg.sender][_sellTokenIndex] -= _orderPrice * _orderAmount;\r\n                tokenBalanceForAddress[_orderOwner][_sellTokenIndex] += _orderPrice * _orderAmount;\r\n                tokenBalanceForAddress[msg.sender][_buyTokenIndex] += _orderAmount;\r\n            } else {\r\n                ExchangeMarket[_marketIndex]\r\n                    .buyOrderBook\r\n                    .orders[_orderIndex]\r\n                    .quantity -= _sell_qty_balance;\r\n                emit LogFulfilBuyOrder(\r\n                    sellTokenSymbol,\r\n                    buyTokenSymbol,\r\n                    _orderIndex,\r\n                    _orderPrice,\r\n                    _orderAmount,\r\n                    block.timestamp\r\n                );\r\n\r\n                tokenBalanceForAddress[msg.sender][_sellTokenIndex] -=\r\n                    _orderPrice *\r\n                    _sell_qty_balance;\r\n                tokenBalanceForAddress[_orderOwner][_sellTokenIndex] +=\r\n                    _orderPrice *\r\n                    _sell_qty_balance;\r\n                tokenBalanceForAddress[msg.sender][_buyTokenIndex] += _sell_qty_balance;\r\n\r\n                _sell_qty_balance = 0;\r\n            }\r\n        }\r\n\r\n        // update sellOrderBook - ordersBook and ordersCount\r\n        uint256 _newBuyOrdersCount = _currBuyOrdersCount - _countBuyOrderFulfiled;\r\n\r\n        uint256[] memory _newBuyOrdersQueue = new uint256[](_newBuyOrdersCount);\r\n        for (uint256 i = 0; i < _newBuyOrdersCount; i++) {\r\n            _newBuyOrdersQueue[i] = ExchangeMarket[_marketIndex].buyOrderBook.ordersQueue[\r\n                i + _countBuyOrderFulfiled\r\n            ];\r\n        }\r\n\r\n        ExchangeMarket[_marketIndex].buyOrderBook.ordersCount = _newBuyOrdersCount;\r\n        ExchangeMarket[_marketIndex].buyOrderBook.ordersQueue = _newBuyOrdersQueue;\r\n    }\r\n\r\n    //User submits limit buy order\r\n    function createBuyOrder(\r\n        string memory buySymbolName,\r\n        string memory sellSymbolName,\r\n        uint256 price,\r\n        uint256 quantity,\r\n        address buyer\r\n    ) private {\r\n        require(hasToken(buySymbolName));\r\n        require(hasToken(sellSymbolName));\r\n        uint8 _sellTokenIndex = getTokenIndex(sellSymbolName);\r\n        require(tokenBalanceForAddress[msg.sender][_sellTokenIndex] >= price * quantity);\r\n\r\n        uint8 _marketIndex = getMarketIndex(buySymbolName, sellSymbolName);\r\n        uint256 _buy_qty_balance = quantity;\r\n\r\n        // fulfil buyOrder by checking against which sell orders can be fulfil\r\n        if (ExchangeMarket[_marketIndex].sellOrderBook.ordersCount > 0) {\r\n            _buy_qty_balance = fulfilBuyOrder(\r\n                buySymbolName,\r\n                sellSymbolName,\r\n                _buy_qty_balance,\r\n                price\r\n            );\r\n        }\r\n        if (_buy_qty_balance > 0) {\r\n            (, uint256[] memory prices, ) = getBuyOrderBook(buySymbolName, sellSymbolName);\r\n\r\n            uint256 _newOrderIndex = ++ExchangeMarket[_marketIndex].buyOrderBook.orderIndex;\r\n            uint256[] memory _newOrdersQueue = new uint256[](_newOrderIndex);\r\n            bool _isOrderAdded = false;\r\n\r\n            if (ExchangeMarket[_marketIndex].buyOrderBook.ordersCount == 0) {\r\n                _newOrdersQueue[0] = _newOrderIndex;\r\n                _isOrderAdded = true;\r\n            } else {\r\n                uint256 _newOrdersQueueIndex = 0;\r\n                for (\r\n                    uint256 i = 0;\r\n                    i < ExchangeMarket[_marketIndex].buyOrderBook.ordersCount;\r\n                    i++\r\n                ) {\r\n                    if (!_isOrderAdded && price > prices[i]) {\r\n                        _newOrdersQueue[_newOrdersQueueIndex++] = _newOrderIndex;\r\n                        _isOrderAdded = true;\r\n                    }\r\n                    _newOrdersQueue[_newOrdersQueueIndex++] = ExchangeMarket[_marketIndex]\r\n                        .buyOrderBook\r\n                        .ordersQueue[i];\r\n                }\r\n                if (!_isOrderAdded) {\r\n                    _newOrdersQueue[_newOrdersQueueIndex] = _newOrderIndex;\r\n                }\r\n            }\r\n            ExchangeMarket[_marketIndex].buyOrderBook.ordersQueue = _newOrdersQueue;\r\n            ExchangeMarket[_marketIndex].buyOrderBook.ordersCount++;\r\n            ExchangeMarket[_marketIndex].buyOrderBook.orders[_newOrderIndex] = Order({\r\n                quantity: _buy_qty_balance,\r\n                price: price,\r\n                user: msg.sender,\r\n                timestamp: block.timestamp,\r\n                status: \"A\"\r\n            });\r\n        }\r\n        tokenBalanceForAddress[msg.sender][_sellTokenIndex] -= price * _buy_qty_balance;\r\n\r\n        // fire event\r\n        emit LogCreateBuyOrder(\r\n            buySymbolName,\r\n            sellSymbolName,\r\n            price,\r\n            _buy_qty_balance,\r\n            buyer,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    //Try if buy order can be immediately fulfilled even if partially\r\n    function fulfilBuyOrder(\r\n        string memory buyTokenSymbol,\r\n        string memory sellTokenSymbol,\r\n        uint256 _buy_qty_balance,\r\n        uint256 price\r\n    ) private returns (uint256) {\r\n        uint8 _buyTokenIndex = getTokenIndex(buyTokenSymbol);\r\n        uint8 _sellTokenIndex = getTokenIndex(sellTokenSymbol);\r\n\r\n        uint8 _marketIndex = getMarketIndex(buyTokenSymbol, sellTokenSymbol);\r\n        uint256 _currSellOrdersCount = ExchangeMarket[_marketIndex].sellOrderBook.ordersCount;\r\n\r\n        uint256 _countSellOrderFulfiled = 0;\r\n        for (uint256 i = 0; i < _currSellOrdersCount; i++) {\r\n            if (_buy_qty_balance == 0) break;\r\n\r\n            uint256 _orderIndex = ExchangeMarket[_marketIndex].sellOrderBook.ordersQueue[i];\r\n            uint256 _orderPrice = ExchangeMarket[_marketIndex]\r\n                .sellOrderBook\r\n                .orders[_orderIndex]\r\n                .price;\r\n            uint256 _orderAmount = ExchangeMarket[_marketIndex]\r\n                .sellOrderBook\r\n                .orders[_orderIndex]\r\n                .quantity;\r\n            address _orderOwner = ExchangeMarket[_marketIndex]\r\n                .sellOrderBook\r\n                .orders[_orderIndex]\r\n                .user;\r\n\r\n            if (price < _orderPrice) break;\r\n\r\n            if (_buy_qty_balance >= _orderAmount) {\r\n                _buy_qty_balance -= _orderAmount;\r\n\r\n                ExchangeMarket[_marketIndex].sellOrderBook.orders[_orderIndex].quantity = 0;\r\n                _countSellOrderFulfiled++;\r\n                emit LogFulfilSellOrder(\r\n                    sellTokenSymbol,\r\n                    buyTokenSymbol,\r\n                    _orderIndex,\r\n                    price,\r\n                    _orderAmount,\r\n                    block.timestamp\r\n                );\r\n\r\n                tokenBalanceForAddress[_orderOwner][_sellTokenIndex] += price * _orderAmount;\r\n                tokenBalanceForAddress[msg.sender][_buyTokenIndex] += _orderAmount;\r\n            } else {\r\n                ExchangeMarket[_marketIndex]\r\n                    .sellOrderBook\r\n                    .orders[_orderIndex]\r\n                    .quantity -= _buy_qty_balance;\r\n                emit LogFulfilSellOrder(\r\n                    sellTokenSymbol,\r\n                    buyTokenSymbol,\r\n                    _orderIndex,\r\n                    price,\r\n                    _orderAmount,\r\n                    block.timestamp\r\n                );\r\n\r\n                tokenBalanceForAddress[_orderOwner][_sellTokenIndex] += price * _buy_qty_balance;\r\n                tokenBalanceForAddress[msg.sender][_buyTokenIndex] += _buy_qty_balance;\r\n\r\n                _buy_qty_balance = 0;\r\n            }\r\n        }\r\n\r\n        // update sellOrderBook - ordersBook and ordersCount\r\n        uint256 _newSellOrdersCount = _currSellOrdersCount - _countSellOrderFulfiled;\r\n\r\n        uint256[] memory _newSellOrdersQueue = new uint256[](_newSellOrdersCount);\r\n        for (uint256 i = 0; i < _newSellOrdersCount; i++) {\r\n            _newSellOrdersQueue[i] = ExchangeMarket[_marketIndex].sellOrderBook.ordersQueue[\r\n                i + _countSellOrderFulfiled\r\n            ];\r\n        }\r\n\r\n        ExchangeMarket[_marketIndex].sellOrderBook.ordersCount = _newSellOrdersCount;\r\n        ExchangeMarket[_marketIndex].sellOrderBook.ordersQueue = _newSellOrdersQueue;\r\n\r\n        return _buy_qty_balance;\r\n    }\r\n\r\n    function createSellOrder(\r\n        string memory sellTokenSymbol,\r\n        string memory buyTokenSymbol,\r\n        uint256 price,\r\n        uint256 quantity,\r\n        address seller\r\n    ) private {\r\n        require(hasToken(sellTokenSymbol));\r\n        require(hasToken(buyTokenSymbol));\r\n\r\n        uint8 _sellTokenIndex = getTokenIndex(sellTokenSymbol);\r\n        require(tokenBalanceForAddress[msg.sender][_sellTokenIndex] >= price * quantity);\r\n\r\n        uint8 _marketIndex = getMarketIndex(buyTokenSymbol, sellTokenSymbol);\r\n        uint256 _sell_qty_balance = quantity;\r\n\r\n        // fulfil sellOrder by checking against which buy orders can be fulfil\r\n        if (ExchangeMarket[_marketIndex].buyOrderBook.ordersCount > 0) {\r\n            _sell_qty_balance = fulfilSellOrder(\r\n                sellTokenSymbol,\r\n                buyTokenSymbol,\r\n                _sell_qty_balance,\r\n                price\r\n            );\r\n        }\r\n\r\n        // check if buyOrder is fully fulfiled\r\n        if (_sell_qty_balance > 0) {\r\n            // Update ordersQueue of OrderBook\r\n            (, uint256[] memory prices, ) = getSellOrderBook(sellTokenSymbol, buyTokenSymbol);\r\n            uint256 _newOrderIndex = ++ExchangeMarket[_marketIndex].sellOrderBook.orderIndex;\r\n            uint256[] memory _newOrdersQueue = new uint256[](_newOrderIndex);\r\n\r\n            bool _isOrderAdded = false;\r\n            if (ExchangeMarket[_marketIndex].sellOrderBook.ordersCount == 0) {\r\n                _newOrdersQueue[0] = _newOrderIndex;\r\n                _isOrderAdded = true;\r\n            } else {\r\n                uint256 _newOrdersQueueIndex = 0;\r\n                for (\r\n                    uint256 _counter = 0;\r\n                    _counter < ExchangeMarket[_marketIndex].sellOrderBook.ordersCount;\r\n                    _counter++\r\n                ) {\r\n                    if (!_isOrderAdded && price < prices[_counter]) {\r\n                        _newOrdersQueue[_newOrdersQueueIndex++] = _newOrderIndex;\r\n                        _isOrderAdded = true;\r\n                    }\r\n                    _newOrdersQueue[_newOrdersQueueIndex++] = ExchangeMarket[_marketIndex]\r\n                        .sellOrderBook\r\n                        .ordersQueue[_counter];\r\n                }\r\n                // for the case of the price being lower than the lowest price of the orderbook\r\n                if (!_isOrderAdded) {\r\n                    _newOrdersQueue[_newOrdersQueueIndex] = _newOrderIndex;\r\n                }\r\n            }\r\n\r\n            // replace existing orders queue is it's not empty\r\n            ExchangeMarket[_marketIndex].sellOrderBook.ordersQueue = _newOrdersQueue;\r\n\r\n            // Add new order to OrderBook\r\n            ExchangeMarket[_marketIndex].sellOrderBook.ordersCount++;\r\n            ExchangeMarket[_marketIndex].sellOrderBook.orders[_newOrderIndex] = Order({\r\n                timestamp: block.timestamp,\r\n                price: price,\r\n                quantity: _sell_qty_balance,\r\n                user: msg.sender,\r\n                status: \"A\"\r\n            });\r\n\r\n            tokenBalanceForAddress[msg.sender][_sellTokenIndex] -= price * _sell_qty_balance;\r\n\r\n            // fire event\r\n            emit LogCreateSellOrder(\r\n                sellTokenSymbol,\r\n                buyTokenSymbol,\r\n                price,\r\n                _sell_qty_balance,\r\n                seller,\r\n                block.timestamp\r\n            );\r\n        }\r\n    }\r\n\r\n    function fulfilSellOrder(\r\n        string memory sellTokenSymbol, //wrt sell order\r\n        string memory buyTokenSymbol,\r\n        uint256 _sell_qty_balance,\r\n        uint256 price\r\n    ) private returns (uint256) {\r\n        uint8 _marketIndex = getMarketIndex(buyTokenSymbol, sellTokenSymbol);\r\n        uint8 _buyTokenIndex = getTokenIndex(buyTokenSymbol);\r\n        uint8 _sellTokenIndex = getTokenIndex(sellTokenSymbol);\r\n        uint256 _currBuyOrdersCount = ExchangeMarket[_marketIndex].buyOrderBook.ordersCount;\r\n\r\n        uint256 _countBuyOrderFulfiled = 0;\r\n\r\n        // update buyOrderBook - orders\r\n        for (uint256 i = 0; i < _currBuyOrdersCount; i++) {\r\n            if (_sell_qty_balance == 0) break;\r\n\r\n            uint256 _orderIndex = ExchangeMarket[_marketIndex].buyOrderBook.ordersQueue[i];\r\n            uint256 _orderPrice = ExchangeMarket[_marketIndex]\r\n                .buyOrderBook\r\n                .orders[_orderIndex]\r\n                .price;\r\n            uint256 _orderAmount = ExchangeMarket[_marketIndex]\r\n                .buyOrderBook\r\n                .orders[_orderIndex]\r\n                .quantity;\r\n            address _orderOwner = ExchangeMarket[_marketIndex]\r\n                .buyOrderBook\r\n                .orders[_orderIndex]\r\n                .user;\r\n\r\n            if (price > _orderPrice) break;\r\n\r\n            if (_sell_qty_balance >= _orderAmount) {\r\n                _sell_qty_balance -= _orderAmount;\r\n\r\n                ExchangeMarket[_marketIndex].buyOrderBook.orders[_orderIndex].quantity = 0;\r\n                _countBuyOrderFulfiled++;\r\n                emit LogFulfilBuyOrder(\r\n                    sellTokenSymbol,\r\n                    buyTokenSymbol,\r\n                    _orderIndex,\r\n                    price,\r\n                    _orderAmount,\r\n                    block.timestamp\r\n                );\r\n\r\n                tokenBalanceForAddress[_orderOwner][_sellTokenIndex] += _orderAmount;\r\n                tokenBalanceForAddress[msg.sender][_buyTokenIndex] += price * _orderAmount;\r\n            } else {\r\n                ExchangeMarket[_marketIndex]\r\n                    .buyOrderBook\r\n                    .orders[_orderIndex]\r\n                    .quantity -= _sell_qty_balance;\r\n                emit LogFulfilBuyOrder(\r\n                    sellTokenSymbol,\r\n                    buyTokenSymbol,\r\n                    _orderIndex,\r\n                    price,\r\n                    _sell_qty_balance,\r\n                    block.timestamp\r\n                );\r\n                tokenBalanceForAddress[_orderOwner][_sellTokenIndex] += _sell_qty_balance;\r\n                tokenBalanceForAddress[msg.sender][_buyTokenIndex] += price * _sell_qty_balance;\r\n\r\n                _sell_qty_balance = 0;\r\n            }\r\n        }\r\n\r\n        // update buyOrderBook - ordersBook and ordersCount\r\n        uint256 _newBuyOrdersCount = _currBuyOrdersCount - _countBuyOrderFulfiled;\r\n\r\n        uint256[] memory _newBuyOrdersQueue = new uint256[](_newBuyOrdersCount);\r\n        for (uint256 i = 0; i < _newBuyOrdersCount; i++) {\r\n            _newBuyOrdersQueue[i] = ExchangeMarket[_marketIndex].buyOrderBook.ordersQueue[\r\n                i + _countBuyOrderFulfiled\r\n            ];\r\n        }\r\n\r\n        ExchangeMarket[_marketIndex].buyOrderBook.ordersCount = _newBuyOrdersCount;\r\n        ExchangeMarket[_marketIndex].buyOrderBook.ordersQueue = _newBuyOrdersQueue;\r\n\r\n        return _sell_qty_balance;\r\n    }\r\n\r\n    //User's ability to cancel orders that were placed\r\n    function cancelBuyOrder(\r\n        string memory buyTokenSymbol,\r\n        string memory sellTokenSymbol,\r\n        uint256 orderIndex\r\n    ) public {\r\n        require(hasToken(buyTokenSymbol));\r\n        require(hasToken(sellTokenSymbol));\r\n\r\n        uint8 _marketIndex = getMarketIndex(buyTokenSymbol, sellTokenSymbol);\r\n        uint8 _sellTokenIndex = getTokenIndex(sellTokenSymbol);\r\n\r\n        require(ExchangeMarket[_marketIndex].buyOrderBook.ordersCount > 0);\r\n\r\n        // Check order is in OrderBook\r\n        // Create new orderQueue\r\n        bool _isOrderInBook = false;\r\n        uint256 _newOrderQueueIndex = 0;\r\n        uint256[] memory _newOrdersQueue = new uint256[](\r\n            ExchangeMarket[_marketIndex].buyOrderBook.ordersCount - 1\r\n        );\r\n        uint256 _price;\r\n        uint256 _quantity;\r\n\r\n        for (\r\n            uint256 _orderQueueIndex = 0;\r\n            _orderQueueIndex < ExchangeMarket[_marketIndex].buyOrderBook.ordersCount;\r\n            _orderQueueIndex++\r\n        ) {\r\n            if (\r\n                orderIndex ==\r\n                ExchangeMarket[_marketIndex].buyOrderBook.ordersQueue[_orderQueueIndex]\r\n            ) {\r\n                _isOrderInBook = true;\r\n                _price = ExchangeMarket[_marketIndex].buyOrderBook.orders[orderIndex].price;\r\n                _quantity = ExchangeMarket[_marketIndex].buyOrderBook.orders[orderIndex].quantity;\r\n            } else {\r\n                _newOrdersQueue[_newOrderQueueIndex] = ExchangeMarket[_marketIndex]\r\n                    .buyOrderBook\r\n                    .ordersQueue[_orderQueueIndex];\r\n                _newOrderQueueIndex++;\r\n            }\r\n        }\r\n        require(_isOrderInBook);\r\n\r\n        // Update OrderBook and OrderQueue\r\n        ExchangeMarket[_marketIndex].buyOrderBook.ordersCount--;\r\n        ExchangeMarket[_marketIndex].buyOrderBook.ordersQueue = _newOrdersQueue;\r\n\r\n        // refund ether balance back to user's account\r\n        tokenBalanceForAddress[msg.sender][_sellTokenIndex] += _price * _quantity;\r\n\r\n        emit LogCancelBuyOrder(\r\n            buyTokenSymbol,\r\n            sellTokenSymbol,\r\n            orderIndex,\r\n            msg.sender,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function cancelSellOrder(\r\n        string memory buyTokenSymbol,\r\n        string memory sellTokenSymbol,\r\n        uint256 orderIndex\r\n    ) public {\r\n        require(hasToken(buyTokenSymbol));\r\n        require(hasToken(sellTokenSymbol));\r\n\r\n        uint8 _marketIndex = getMarketIndex(buyTokenSymbol, sellTokenSymbol);\r\n        uint8 _sellTokenIndex = getTokenIndex(sellTokenSymbol);\r\n\r\n        require(ExchangeMarket[_marketIndex].sellOrderBook.ordersCount > 0);\r\n\r\n        // Check order is in OrderBook\r\n        // Create new orderQueue\r\n        bool _isOrderInBook = false;\r\n        uint256 _newOrderQueueIndex = 0;\r\n        uint256[] memory _newOrdersQueue = new uint256[](\r\n            ExchangeMarket[_marketIndex].sellOrderBook.ordersCount - 1\r\n        );\r\n        uint256 _quantity;\r\n\r\n        for (\r\n            uint256 _orderQueueIndex = 0;\r\n            _orderQueueIndex < ExchangeMarket[_marketIndex].sellOrderBook.ordersCount;\r\n            _orderQueueIndex++\r\n        ) {\r\n            if (\r\n                orderIndex ==\r\n                ExchangeMarket[_marketIndex].sellOrderBook.ordersQueue[_orderQueueIndex]\r\n            ) {\r\n                _isOrderInBook = true;\r\n                _quantity = ExchangeMarket[_marketIndex].sellOrderBook.orders[orderIndex].quantity;\r\n            } else {\r\n                _newOrdersQueue[_newOrderQueueIndex] = ExchangeMarket[_marketIndex]\r\n                    .sellOrderBook\r\n                    .ordersQueue[_orderQueueIndex];\r\n                _newOrderQueueIndex++;\r\n            }\r\n        }\r\n        require(_isOrderInBook);\r\n\r\n        // Update OrderBook and OrderQueue\r\n        ExchangeMarket[_marketIndex].sellOrderBook.ordersCount--;\r\n        ExchangeMarket[_marketIndex].sellOrderBook.ordersQueue = _newOrdersQueue;\r\n\r\n        // refund token balance back to user's account\r\n        tokenBalanceForAddress[msg.sender][_sellTokenIndex] += _quantity;\r\n\r\n        emit LogCancelSellOrder(\r\n            buyTokenSymbol,\r\n            sellTokenSymbol,\r\n            orderIndex,\r\n            msg.sender,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    /* HELPER FUNCTION */\r\n\r\n    function hasToken(string memory symbolName) public view returns (bool) {\r\n        for (uint8 i = 1; i <= tokenIndex; i++) {\r\n            if (\r\n                keccak256(abi.encodePacked(symbolName)) ==\r\n                keccak256(abi.encodePacked(tokenInfo[i].symbolName))\r\n            ) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /* GETTER FUNCTIONS */\r\n\r\n    function getBuyOrderBook(string memory buyTokenSymbol, string memory sellTokenSymbol)\r\n        public\r\n        view\r\n        returns (\r\n            uint256[] memory,\r\n            uint256[] memory,\r\n            uint256[] memory\r\n        )\r\n    {\r\n        uint8 _marketIndex = getMarketIndex(buyTokenSymbol, sellTokenSymbol);\r\n\r\n        uint256[] memory indexes = new uint256[](\r\n            ExchangeMarket[_marketIndex].buyOrderBook.ordersCount\r\n        );\r\n        uint256[] memory prices = new uint256[](\r\n            ExchangeMarket[_marketIndex].buyOrderBook.ordersCount\r\n        );\r\n        uint256[] memory quantity = new uint256[](\r\n            ExchangeMarket[_marketIndex].buyOrderBook.ordersCount\r\n        );\r\n\r\n        for (uint256 i = 1; i <= ExchangeMarket[_marketIndex].buyOrderBook.ordersCount; i++) {\r\n            Order memory _order = ExchangeMarket[_marketIndex].buyOrderBook.orders[\r\n                ExchangeMarket[_marketIndex].buyOrderBook.ordersQueue[i - 1]\r\n            ];\r\n            indexes[i - 1] = ExchangeMarket[_marketIndex].buyOrderBook.ordersQueue[i - 1];\r\n            prices[i - 1] = _order.price;\r\n            quantity[i - 1] = _order.quantity;\r\n        }\r\n\r\n        return (indexes, prices, quantity);\r\n    }\r\n\r\n    function getSellOrderBook(string memory sellTokenSymbol, string memory buyTokenSymbol)\r\n        public\r\n        view\r\n        returns (\r\n            uint256[] memory,\r\n            uint256[] memory,\r\n            uint256[] memory\r\n        )\r\n    {\r\n        uint8 _marketIndex = getMarketIndex(sellTokenSymbol, buyTokenSymbol);\r\n\r\n        uint256[] memory indexes = new uint256[](\r\n            ExchangeMarket[_marketIndex].sellOrderBook.ordersCount\r\n        );\r\n        uint256[] memory prices = new uint256[](\r\n            ExchangeMarket[_marketIndex].sellOrderBook.ordersCount\r\n        );\r\n        uint256[] memory quantity = new uint256[](\r\n            ExchangeMarket[_marketIndex].sellOrderBook.ordersCount\r\n        );\r\n\r\n        for (uint256 i = 1; i <= ExchangeMarket[_marketIndex].sellOrderBook.ordersCount; i++) {\r\n            Order memory _order = ExchangeMarket[_marketIndex].sellOrderBook.orders[\r\n                ExchangeMarket[_marketIndex].sellOrderBook.ordersQueue[i - 1]\r\n            ];\r\n            indexes[i - 1] = ExchangeMarket[_marketIndex].sellOrderBook.ordersQueue[i - 1];\r\n            prices[i - 1] = _order.price;\r\n            quantity[i - 1] = _order.quantity;\r\n        }\r\n\r\n        return (indexes, prices, quantity);\r\n    }\r\n\r\n    function getTokenAddress(string memory symbolName) public view returns (address) {\r\n        require(hasToken(symbolName));\r\n\r\n        uint8 _tokenIndex = getTokenIndex(symbolName);\r\n\r\n        return tokenInfo[_tokenIndex].contractAddress;\r\n    }\r\n\r\n    function getTokenIndex(string memory symbolName) public view returns (uint8) {\r\n        for (uint8 i = 1; i <= tokenIndex; i++) {\r\n            if (keccak256(bytes(symbolName)) == keccak256(bytes(tokenInfo[i].symbolName))) {\r\n                return i;\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function getMarketIndex(string memory buyTokenSymbol, string memory sellTokenSymbol)\r\n        public\r\n        view\r\n        returns (uint8)\r\n    {\r\n        for (uint8 i = 1; i <= marketIndex; i++) {\r\n            if (\r\n                keccak256(bytes(buyTokenSymbol)) ==\r\n                keccak256(bytes(tokenInfo[buyToSell[i][0]].symbolName)) &&\r\n                keccak256(bytes(sellTokenSymbol)) ==\r\n                keccak256(bytes(tokenInfo[buyToSell[i][1]].symbolName))\r\n            ) {\r\n                return i;\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function getTokenBalanceForUser(string memory symbolName) public view returns (uint256) {\r\n        return tokenBalanceForAddress[msg.sender][getTokenIndex(symbolName)];\r\n    }\r\n\r\n    function getAllTokenBalanceForUser() public view returns (string[] memory, uint256[] memory) {\r\n        string[] memory symbolNames = new string[](tokenIndex - 1);\r\n        uint256[] memory balances = new uint256[](tokenIndex - 1);\r\n        for (uint8 i = 1; i <= tokenIndex; i++) {\r\n            symbolNames[i - 1] = tokenInfo[i].symbolName;\r\n            balances[i - 1] = getTokenBalanceForUser(tokenInfo[i].symbolName);\r\n        }\r\n        return (symbolNames, balances);\r\n    }\r\n\r\n    //orderIndex, buy/sell tokensymbol, buy or sell, price, quantity\r\n    function getOpenOrdersForUser()\r\n        public\r\n        view\r\n        returns (\r\n            uint256[] memory, /*orderIndex*/\r\n            string[] memory, /*buy/sell tokensymbol*/\r\n            string[] memory, /*buy/sell tokensymbol*/\r\n            string[] memory, /*buy or sell*/\r\n            uint256[] memory, /*price*/\r\n            uint256[] memory, /*quantity*/\r\n            uint8\r\n        )\r\n    {\r\n        uint256[] memory orderIndexes = new uint256[](20); /*orderIndex*/\r\n        string[] memory buySymbols = new string[](20); /*buy/sell tokensymbol*/\r\n        string[] memory sellSymbols = new string[](20); /*buy/sell tokensymbol*/\r\n        string[] memory types = new string[](20); /*buy or sell*/\r\n        uint256[] memory prices = new uint256[](20); /*price*/\r\n        uint256[] memory quantities = new uint256[](20); /*quantity*/\r\n        uint8 count = 0;\r\n\r\n        for (uint8 i = 1; i <= marketIndex; i++) {\r\n            for (uint256 j = 1; j <= ExchangeMarket[i].sellOrderBook.ordersCount; j++) {\r\n                Order memory _order = ExchangeMarket[i].sellOrderBook.orders[\r\n                    ExchangeMarket[i].sellOrderBook.ordersQueue[j - 1]\r\n                ];\r\n                if (_order.user == msg.sender) {\r\n                    count++;\r\n                    orderIndexes[count - 1] = ExchangeMarket[i].sellOrderBook.ordersQueue[j - 1];\r\n                    buySymbols[count - 1] = tokenInfo[buyToSell[i][0]].symbolName;\r\n                    sellSymbols[count - 1] = tokenInfo[buyToSell[i][1]].symbolName;\r\n                    types[count - 1] = \"sell\";\r\n                    prices[count - 1] = _order.price;\r\n                    quantities[count - 1] = _order.quantity;\r\n                }\r\n            }\r\n            for (uint256 j = 1; j <= ExchangeMarket[i].buyOrderBook.ordersCount; j++) {\r\n                Order memory _order = ExchangeMarket[i].buyOrderBook.orders[\r\n                    ExchangeMarket[i].buyOrderBook.ordersQueue[j - 1]\r\n                ];\r\n                if (_order.user == msg.sender) {\r\n                    count++;\r\n                    orderIndexes[count - 1] = ExchangeMarket[i].buyOrderBook.ordersQueue[j - 1];\r\n                    buySymbols[count - 1] = tokenInfo[buyToSell[i][0]].symbolName;\r\n                    sellSymbols[count - 1] = tokenInfo[buyToSell[i][1]].symbolName;\r\n                    types[count - 1] = \"buy\";\r\n                    prices[count - 1] = _order.price;\r\n                    quantities[count - 1] = _order.quantity;\r\n                }\r\n            }\r\n        }\r\n\r\n        return (orderIndexes, buySymbols, sellSymbols, types, prices, quantities, count);\r\n    }\r\n\r\n    function getAllTokens() public view returns (string[] memory, address[] memory) {\r\n        string[] memory symbolNames = new string[](tokenIndex - 1);\r\n        address[] memory addresses = new address[](tokenIndex - 1);\r\n\r\n        for (uint8 i = 1; i <= tokenIndex; i++) {\r\n            symbolNames[i - 1] = tokenInfo[i].symbolName;\r\n            addresses[i - 1] = tokenInfo[i].contractAddress;\r\n        }\r\n\r\n        return (symbolNames, addresses);\r\n    }\r\n\r\n    function getAllMarkets() public view returns (string[] memory, string[] memory) {\r\n        string[] memory buySymbols = new string[](marketIndex - 1);\r\n        string[] memory sellSymbols = new string[](marketIndex - 1);\r\n\r\n        for (uint8 i = 1; i <= marketIndex; i++) {\r\n            buySymbols[i - 1] = tokenInfo[buyToSell[i][0]].symbolName;\r\n            sellSymbols[i - 1] = tokenInfo[buyToSell[i][1]].symbolName;\r\n        }\r\n\r\n        return (buySymbols, sellSymbols);\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}